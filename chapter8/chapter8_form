**DFS와 BFS 기본 형식**
1. BFS (너비 우선 탐색) : "Queue와 친구들"
BFS는 최단 거리를 구하거나, 시작점에서 가까운 곳부터 순차적으로 퍼져 나갈 때 사용합니다.

💡 핵심 로직
Queue를 생성하고 시작 노드를 넣는다.

시작 노드를 방문 처리(ch[v] = 1)한다.

Queue가 빌 때까지 while문을 돌린다.

Queue에서 하나를 꺼내(poll) 그놈의 인접한 이웃들을 살핀다.

아직 안 가본 곳이면 Queue에 넣고 방문 처리를 한다.

📝 BFS 표준 코드 (Java)
Java

public void BFS(int startNode) {
    Queue<Integer> Q = new LinkedList<>();
    Q.offer(startNode);
    ch[startNode] = 1; // 시작점 방문 표시
    int L = 0; // 레벨(깊이)이 필요할 경우

    while (!Q.isEmpty()) {
        int len = Q.size(); // 현재 레벨에 있는 노드 개수
        for (int i = 0; i < len; i++) { // 현재 레벨 모두 처리
            int v = Q.poll();
            
            // v와 연결된 이웃들 확인 (아까 배운 ArrayList 구조 활용)
            for (int nv : graph.get(v)) {
                if (ch[nv] == 0) { // 방문 안 했으면
                    ch[nv] = 1;
                    Q.offer(nv);
                }
            }
        }
        L++; // 한 층(Level) 분석 끝
    }
}
2. DFS (깊이 우선 탐색) : "재귀(Recursion)와 백트래킹"
DFS는 모든 경우의 수를 탐색하거나, 한 놈만 끝까지 패서 경로의 특징을 확인해야 할 때 사용합니다.

💡 핵심 로직
재귀 함수 형태로 만든다. (함수 자체가 스택 역할을 함)

종료 조건을 가장 위에 적는다 (예: if(v == target)).

방문하지 않은 이웃 노드로 재귀 호출을 한다.

(중요) 경로 탐색일 경우, 나올 때 방문 해제(ch[v] = 0)를 해준다 (백트래킹).

📝 DFS 표준 코드 (Java)
Java

public void DFS(int v) {
    // 1. 종료 조건 (Base Case)
    if (v == n) {
        answer++; // 목표 도달 시 정답 처리
    } 
    // 2. 재귀 단계 (Recursive Step)
    else {
        for (int nv : graph.get(v)) {
            if (ch[nv] == 0) {
                ch[nv] = 1;   // 방문 체크 (들어가면서)
                DFS(nv);      // 더 깊이 이동
                ch[nv] = 0;   // 방문 해제 (나오면서) -> 이게 백트래킹!
            }
        }
    }
}

💡 문제 풀 때 팁
**"가장 빠른 길(최단)"**이라는 단어가 보이면? 고민하지 말고 BFS로 가세요.

"모든 경우를 다 해봐야 한다" 혹은 **"특정 경로를 찾아라"**면? DFS가 유리합니다.

